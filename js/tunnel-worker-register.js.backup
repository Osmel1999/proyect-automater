/**
 * üîß KDS Tunnel - Sistema de T√∫nel por Navegador
 * 
 * M√≥dulo compartido que gestiona el Service Worker de t√∫nel
 * y expone una API global para que cada p√°gina pueda controlar
 * el estado del t√∫nel de forma independiente.
 * 
 * @namespace KDSTunnel
 * @version 2.0.0
 */

(function() {
  'use strict';

  // Verificar soporte de Service Worker
  if (!('serviceWorker' in navigator)) {
    console.warn('‚ö†Ô∏è Service Workers no soportados en este navegador');
    return;
  }

  // ========================================
  // ESTADO INTERNO
  // ========================================
  
  let tunnelState = {
    status: 'initializing',  // initializing, active, pending, disconnected, error
    tenantId: null,
    page: window.location.pathname,
    timestamp: Date.now(),
    isServiceWorkerReady: false,
    lastError: null
  };

  const eventListeners = new Map();  // Para sistema de eventos
  let indicatorElement = null;       // Referencia al indicador visual

  const eventListeners = new Map();  // Para sistema de eventos
  let indicatorElement = null;       // Referencia al indicador visual

  // ========================================
  // API P√öBLICA
  // ========================================
  
  /**
   * API Global del Sistema de T√∫nel
   */
  window.KDSTunnel = {
    /**
     * Verificar si el t√∫nel est√° activo
     * @returns {boolean}
     */
    isActive: function() {
      return tunnelState.status === 'active' && 
             tunnelState.isServiceWorkerReady &&
             navigator.serviceWorker.controller !== null;
    },

    /**
     * Obtener estado completo del t√∫nel
     * @returns {Object}
     */
    getStatus: function() {
      return { ...tunnelState };
    },

    /**
     * Forzar reconexi√≥n del t√∫nel
     * @returns {Promise<void>}
     */
    forceReconnect: async function() {
      console.log('üîÑ [KDSTunnel] Forzando reconexi√≥n...');
      
      if (!navigator.serviceWorker.controller) {
        throw new Error('Service Worker no disponible');
      }

      // Enviar mensaje de reconexi√≥n
      navigator.serviceWorker.controller.postMessage({
        type: 'tunnel.reconnect'
      });

      updateState('pending', null, 'Reconexi√≥n forzada');
    },

    /**
     * Desconectar t√∫nel
     */
    disconnect: function() {
      console.log('üîå [KDSTunnel] Desconectando t√∫nel...');
      
      if (navigator.serviceWorker.controller) {
        navigator.serviceWorker.controller.postMessage({
          type: 'tunnel.disconnect'
        });
      }

      updateState('disconnected', null, 'Desconexi√≥n manual');
    },

    /**
     * Suscribirse a eventos
     * @param {string} event - Nombre del evento
     * @param {Function} callback - Funci√≥n a ejecutar
     */
    on: function(event, callback) {
      if (typeof callback !== 'function') {
        throw new Error('Callback debe ser una funci√≥n');
      }

      if (!eventListeners.has(event)) {
        eventListeners.set(event, []);
      }

      eventListeners.get(event).push(callback);
    },

    /**
     * Desuscribirse de eventos
     * @param {string} event - Nombre del evento
     * @param {Function} callback - Funci√≥n a remover
     */
    off: function(event, callback) {
      if (!eventListeners.has(event)) return;

      const listeners = eventListeners.get(event);
      const index = listeners.indexOf(callback);
      
      if (index > -1) {
        listeners.splice(index, 1);
      }
    },

    /**
     * Mostrar indicador visual
     * @param {Object} options - Configuraci√≥n del indicador
     */
    showIndicator: function(options = {}) {
      const config = {
        position: options.position || 'bottom-right',
        style: options.style || 'minimal',
        autoHide: options.autoHide !== undefined ? options.autoHide : false,
        theme: options.theme || 'auto',
        ...options
      };

      createIndicator(config);
      updateIndicatorVisual(tunnelState.status);
    },

    /**
     * Ocultar indicador visual
     */
    hideIndicator: function() {
      if (indicatorElement && indicatorElement.parentNode) {
        indicatorElement.remove();
        indicatorElement = null;
      }
    },

    /**
     * Actualizar estado del indicador
     * @param {string} status - Nuevo estado
     */
    updateIndicator: function(status) {
      updateIndicatorVisual(status);
    },

    /**
     * Obtener informaci√≥n de debug
     * @returns {Object}
     */
    getDebugInfo: function() {
      return {
        state: tunnelState,
        serviceWorkerReady: navigator.serviceWorker.controller !== null,
        serviceWorkerState: navigator.serviceWorker.controller?.state,
        listeners: Array.from(eventListeners.keys()),
        indicatorVisible: indicatorElement !== null
      };
    }
  };

  // ========================================
  // FUNCIONES INTERNAS
  // ========================================

  /**
   * Emitir evento a todos los listeners
   */
  function emitEvent(eventName, data) {
    if (!eventListeners.has(eventName)) return;

    const listeners = eventListeners.get(eventName);
    listeners.forEach(callback => {
      try {
        callback(data);
      } catch (error) {
        console.error(`‚ùå [KDSTunnel] Error en listener de ${eventName}:`, error);
      }
    });
  }

  /**
   * Actualizar estado y notificar
   */
  function updateState(status, error = null, reason = '') {
    const oldStatus = tunnelState.status;
    
    tunnelState.status = status;
    tunnelState.timestamp = Date.now();
    tunnelState.lastError = error;

    console.log(`üìä [KDSTunnel] Estado: ${oldStatus} ‚Üí ${status}`, reason);

    // Emitir evento de cambio de estado
    emitEvent('status-change', { 
      status, 
      oldStatus, 
      reason,
      timestamp: tunnelState.timestamp 
    });

    // Emitir eventos espec√≠ficos
    if (status === 'active') {
      emitEvent('connected', { tenantId: tunnelState.tenantId });
    } else if (status === 'disconnected') {
      emitEvent('disconnected', { reason, fallbackToRailway: true });
    } else if (status === 'error') {
      emitEvent('error', { error, reason });
    }

    // Actualizar indicador visual si existe
    updateIndicatorVisual(status);
  }

    try {
      console.log('üîß Registrando Service Worker de t√∫nel...');

      const registration = await navigator.serviceWorker.register('/sw-tunnel.js', {
        scope: '/'
      });

      console.log('‚úÖ Service Worker registrado:', registration.scope);

      // Verificar si hay actualizaci√≥n
      registration.addEventListener('updatefound', () => {
        const newWorker = registration.installing;
        console.log('üîÑ Nueva versi√≥n del Service Worker detectada');

        newWorker.addEventListener('statechange', () => {
          if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
            console.log('‚ú® Nueva versi√≥n instalada - Recarga para activar');
            // Opcional: Notificar al usuario
            showUpdateNotification();
          }
        });
      });

      // Verificar estado del t√∫nel
      if (navigator.serviceWorker.controller) {
        console.log('üåê T√∫nel de conexi√≥n activo');
        updateTunnelStatus('active');
      } else {
        console.log('‚è≥ Esperando activaci√≥n del t√∫nel...');
        updateTunnelStatus('pending');
      }

    } catch (error) {
      console.error('‚ùå Error registrando Service Worker:', error);
      updateTunnelStatus('error');
    }
  }

  /**
   * Actualizar indicador visual del t√∫nel
   */
  function updateTunnelStatus(status) {
    // Crear o actualizar indicador de t√∫nel
    let indicator = document.getElementById('tunnel-indicator');
    
    if (!indicator) {
      indicator = document.createElement('div');
      indicator.id = 'tunnel-indicator';
      indicator.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: bold;
        z-index: 10000;
        display: flex;
        align-items: center;
        gap: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      `;
      document.body.appendChild(indicator);
    }

    const statusConfig = {
      'active': {
        color: '#10b981',
        bg: '#d1fae5',
        text: 'üåê T√∫nel Activo',
        title: 'Usando IP del restaurante'
      },
      'pending': {
        color: '#f59e0b',
        bg: '#fef3c7',
        text: '‚è≥ Activando t√∫nel...',
        title: 'Espere un momento'
      },
      'disconnected': {
        color: '#f59e0b',
        bg: '#fef3c7',
        text: 'üîÑ Reconectando...',
        title: 'Usando Railway temporalmente'
      },
      'error': {
        color: '#ef4444',
        bg: '#fee2e2',
        text: '‚ùå Error en t√∫nel',
        title: 'Recargue la p√°gina'
      }
    };

    const config = statusConfig[status];
    indicator.style.backgroundColor = config.bg;
    indicator.style.color = config.color;
    indicator.innerHTML = config.text;
    indicator.title = config.title;
  }

  /**
   * Mostrar notificaci√≥n de actualizaci√≥n
   */
  function showUpdateNotification() {
    const notification = document.createElement('div');
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: #3b82f6;
      color: white;
      padding: 16px 24px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 10001;
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-width: 300px;
    `;

    notification.innerHTML = `
      <div style="font-weight: bold;">‚ú® Actualizaci√≥n disponible</div>
      <div style="font-size: 14px;">Nueva versi√≥n del sistema de t√∫nel</div>
      <button 
        onclick="window.location.reload()" 
        style="
          background: white;
          color: #3b82f6;
          border: none;
          padding: 8px 16px;
          border-radius: 4px;
          cursor: pointer;
          font-weight: bold;
        "
      >
        Recargar ahora
      </button>
    `;

    document.body.appendChild(notification);

    // Auto-cerrar despu√©s de 10 segundos
    setTimeout(() => {
      notification.remove();
    }, 10000);
  }

  /**
   * Comunicaci√≥n con Service Worker
   */
  function setupCommunication() {
    if (!navigator.serviceWorker.controller) {
      return;
    }

    // Escuchar mensajes del Service Worker
    navigator.serviceWorker.addEventListener('message', (event) => {
      console.log('üì® Mensaje del Service Worker:', event.data);
      
      if (event.data.type === 'tunnel.status') {
        updateTunnelStatus(event.data.status);
      } else if (event.data.type === 'tunnel.connected') {
        console.log('üåê T√∫nel conectado para tenant:', event.data.tenantId);
        updateTunnelStatus('active');
      } else if (event.data.type === 'tunnel.disconnected') {
        console.warn('‚ö†Ô∏è T√∫nel desconectado:', event.data.reason);
        updateTunnelStatus('disconnected');
        
        if (event.data.fallbackToRailway) {
          showFallbackNotification();
        }
      } else if (event.data.type === 'get.tenantId') {
        // Responder con tenantId
        const tenantId = getTenantId();
        event.ports[0]?.postMessage({ tenantId });
      }
    });

    // Enviar informaci√≥n del tenant al Service Worker
    const tenantId = getTenantId();
    if (tenantId) {
      navigator.serviceWorker.controller.postMessage({
        type: 'tenant.info',
        tenantId: tenantId
      });
    }
  }

  /**
   * Mostrar notificaci√≥n de fallback a Railway
   */
  function showFallbackNotification() {
    const notification = document.createElement('div');
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: #f59e0b;
      color: white;
      padding: 16px 24px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 10001;
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-width: 320px;
    `;

    notification.innerHTML = `
      <div style="font-weight: bold; display: flex; align-items: center; gap: 8px;">
        ‚ö†Ô∏è T√∫nel Desconectado
      </div>
      <div style="font-size: 14px;">
        Usando conexi√≥n Railway. Tu sesi√≥n WhatsApp sigue activa.
      </div>
      <div style="font-size: 12px; opacity: 0.9;">
        Intentando reconectar t√∫nel...
      </div>
    `;

    document.body.appendChild(notification);

    // Auto-cerrar despu√©s de 5 segundos
    setTimeout(() => {
      notification.style.opacity = '0';
      notification.style.transition = 'opacity 0.3s';
      setTimeout(() => notification.remove(), 300);
    }, 5000);
  }

  /**
   * Obtener Tenant ID actual
   */
  function getTenantId() {
    // Obtener de localStorage o URL
    const stored = localStorage.getItem('tenantId');
    if (stored) return stored;

    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get('tenant') || urlParams.get('tenantId');
  }

  /**
   * Inicializaci√≥n
   */
  window.addEventListener('load', () => {
    registerTunnelWorker();
    setupCommunication();

    console.log('üöÄ Sistema de t√∫nel inicializado');
    console.log('üí° WhatsApp ver√° la IP de este dispositivo');
  });

  // Reconectar si la pesta√±a estaba inactiva
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden) {
      if (navigator.serviceWorker.controller) {
        navigator.serviceWorker.controller.postMessage({
          type: 'ping'
        });
      }
    }
  });

})();
